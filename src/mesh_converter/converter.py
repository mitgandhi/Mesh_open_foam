"""STEP to INP conversion helpers.

This module implements a lightweight, dependency free conversion routine that
extracts vertices from a STEP file and emits a toy finite element mesh in the
ABAQUS ``.inp`` format.  The implementation is intentionally conservative so it
can operate without the full OpenFOAM or pythonocc toolchain being available in
this execution environment.  The generated mesh is sufficient for
proof-of-concept experiments and documents how a real converter could integrate
with OpenFOAM.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
import re
from typing import Iterable, List, Sequence, Tuple

Coordinate = Tuple[float, float, float]


@dataclass
class _NodeRecord:
    """Internal representation of a node line inside an INP file."""

    line_index: int
    node_id: int
    x: float
    y: float
    z: float
    suffix: str


@dataclass
class ConversionSummary:
    """Summary of the STEP to INP conversion result."""

    node_count: int
    element_count: int
    ignored_points: int = 0



_COORDINATE_PATTERN = re.compile(
    r"\(\s*(?P<x>[-+]?[0-9]*\.?[0-9]+(?:[Ee][-+]?[0-9]+)?)"
    r"\s*[,;]\s*(?P<y>[-+]?[0-9]*\.?[0-9]+(?:[Ee][-+]?[0-9]+)?)"
    r"\s*[,;]\s*(?P<z>[-+]?[0-9]*\.?[0-9]+(?:[Ee][-+]?[0-9]+)?)\s*\)"
)



class StepParseError(RuntimeError):
    """Raised when the STEP file cannot be parsed."""


class InputFileError(RuntimeError):
    """Raised when input validation fails."""


class InpParseError(RuntimeError):
    """Raised when the INP file cannot be parsed."""


_COORDINATE_PATTERN = re.compile(
    r"\(\s*(?P<x>[-+]?[0-9]*\.?[0-9]+(?:[Ee][-+]?[0-9]+)?)"
    r"\s*,\s*(?P<y>[-+]?[0-9]*\.?[0-9]+(?:[Ee][-+]?[0-9]+)?)"
    r"\s*,\s*(?P<z>[-+]?[0-9]*\.?[0-9]+(?:[Ee][-+]?[0-9]+)?)\s*\)"
)

_NODE_LINE_PATTERN = re.compile(
    r"\s*(?P<id>\d+)\s*,\s*"
    r"(?P<x>[-+]?[0-9]*\.?[0-9]+(?:[Ee][-+]?[0-9]+)?)\s*,\s*"
    r"(?P<y>[-+]?[0-9]*\.?[0-9]+(?:[Ee][-+]?[0-9]+)?)\s*,\s*"
    r"(?P<z>[-+]?[0-9]*\.?[0-9]+(?:[Ee][-+]?[0-9]+)?)"
    r"(?P<suffix>.*)$"
)


def _normalise_coordinates(coordinates: Iterable[Coordinate]) -> List[Coordinate]:
    """Remove duplicate coordinates while preserving order."""

    seen = set()
    unique: List[Coordinate] = []
    for coord in coordinates:
        if coord not in seen:
            seen.add(coord)
            unique.append(coord)
    return unique


def _chunked(sequence: Sequence[Coordinate], chunk_size: int) -> Iterable[Sequence[Coordinate]]:
    """Yield *chunk_size* sized slices from *sequence*."""

    for start in range(0, len(sequence), chunk_size):
        yield sequence[start : start + chunk_size]


def _extract_coordinates(step_text: str) -> List[Coordinate]:
    """Extract XYZ coordinates from the STEP document.

    The parser is intentionally simple but performs well enough for STEP files
    that contain explicit coordinate triples in standard formats.  The
    conversion uses a forgiving regular expression that can match both comma and
    semicolon separated triples, which covers STEP files exported by popular CAD
    tools.
    """

    coordinates: List[Coordinate] = []
    for match in _COORDINATE_PATTERN.finditer(step_text):
        try:
            x = float(match.group("x"))
            y = float(match.group("y"))
            z = float(match.group("z"))
        except ValueError as exc:  # pragma: no cover - defensive guard
            raise StepParseError("Failed to parse coordinate triple") from exc
        coordinates.append((x, y, z))

    return coordinates


def _format_inp(nodes: Sequence[Coordinate], elements: Sequence[Sequence[int]], source: Path) -> str:
    """Build the textual contents of the ABAQUS ``.inp`` mesh file."""

    lines = [
        "*Heading",
        f"** Converted from STEP: {source.name}",
        "** This file was generated by the lightweight mesh_converter tool.",
        "*Node",
    ]

    for index, (x, y, z) in enumerate(nodes, start=1):
        lines.append(f"{index}, {x:.6f}, {y:.6f}, {z:.6f}")

    if elements:
        lines.append("*Element, type=T3D2")
        for index, element in enumerate(elements, start=1):
            node_indices = ", ".join(str(node_index) for node_index in element)
            lines.append(f"{index}, {node_indices}")

    return "\n".join(lines) + "\n"


def convert_step_to_inp(input_path: Path | str, output_path: Path | str) -> ConversionSummary:
    """Convert *input_path* STEP file into an ABAQUS ``.inp`` mesh file.

    The converter extracts all coordinate triples present in the STEP document
    and constructs a simple element connectivity table by grouping the
    coordinates into triples.  Real-world pipelines would typically perform a
    more sophisticated meshing step (e.g. via ``gmsh`` or OpenFOAM utilities).

    Parameters
    ----------
    input_path:
        The STEP file to read.  Files must use either the ``.stp`` or
        ``.step`` extensions.
    output_path:
        Destination path for the generated ``.inp`` file.
    """

    input_path = Path(input_path)
    output_path = Path(output_path)

    if not input_path.exists():
        raise InputFileError(f"Input STEP file does not exist: {input_path}")

    if input_path.suffix.lower() not in {".stp", ".step"}:
        raise InputFileError("Input file must have a .stp or .step extension")

    step_text = input_path.read_text(encoding="utf-8", errors="ignore")
    raw_coordinates = _extract_coordinates(step_text)

    if not raw_coordinates:
        raise StepParseError("No coordinate triples found in STEP file")

    nodes = _normalise_coordinates(raw_coordinates)
    ignored_points = len(raw_coordinates) - len(nodes)

    elements: List[List[int]] = []
    for chunk in _chunked(nodes, 3):
        if len(chunk) == 3:
            # Nodes are 1-indexed in the .inp format
            indices = [nodes.index(node) + 1 for node in chunk]
            elements.append(indices)

    inp_text = _format_inp(nodes, elements, input_path)
    output_path.write_text(inp_text, encoding="utf-8")

    return ConversionSummary(
        node_count=len(nodes),
        element_count=len(elements),
        ignored_points=ignored_points,
    )


def _collect_inp_nodes(lines: Sequence[str]) -> List[_NodeRecord]:
    """Extract node definitions from the textual representation of an INP file."""

    nodes: List[_NodeRecord] = []
    in_node_block = False

    for index, line in enumerate(lines):
        stripped = line.strip()

        if stripped.startswith("*"):
            in_node_block = stripped.lower().startswith("*node")
            continue

        if not in_node_block or not stripped:
            continue

        match = _NODE_LINE_PATTERN.match(line)
        if not match:
            raise InpParseError(f"Failed to parse node definition on line {index + 1}: {line.strip()}")

        nodes.append(
            _NodeRecord(
                line_index=index,
                node_id=int(match.group("id")),
                x=float(match.group("x")),
                y=float(match.group("y")),
                z=float(match.group("z")),
                suffix=match.group("suffix"),
            )
        )

    return nodes


def stretch_inp_geometry(
    input_path: Path | str,
    output_path: Path | str,
    extend_x: float = 0.0,
    extend_y: float = 0.0,
    extend_z: float = 0.0,
) -> StretchSummary:
    """Stretch the spatial extents of an INP mesh along the principal axes.

    The function keeps the minimum coordinate along each axis fixed and scales the
    relative positions of the nodes so that the bounding box grows by the
    requested *extend_* amount.  For example, if the X range currently spans
    10 mm and ``extend_x`` is ``5`` the new range will measure 15 mm while the
    minimum X coordinate remains unchanged.
    """

    input_path = Path(input_path)
    output_path = Path(output_path)

    if not input_path.exists():
        raise InputFileError(f"Input INP file does not exist: {input_path}")

    if input_path.suffix.lower() != ".inp":
        raise InputFileError("Input file must have a .inp extension when stretching geometry")

    text = input_path.read_text(encoding="utf-8", errors="ignore")
    lines = text.splitlines()
    trailing_newline = text.endswith("\n")

    nodes = _collect_inp_nodes(lines)
    if not nodes:
        raise InpParseError("No *Node section found in the INP file")

    xs = [node.x for node in nodes]
    ys = [node.y for node in nodes]
    zs = [node.z for node in nodes]

    min_x, max_x = min(xs), max(xs)
    min_y, max_y = min(ys), max(ys)
    min_z, max_z = min(zs), max(zs)

    original_lengths = (
        max_x - min_x,
        max_y - min_y,
        max_z - min_z,
    )

    extensions = (extend_x, extend_y, extend_z)
    scales: List[float] = []
    new_lengths: List[float] = []

    for axis, length, extension in zip("XYZ", original_lengths, extensions):
        if length == 0.0:
            if abs(extension) > 0.0:
                raise InpParseError(
                    f"Cannot adjust length along {axis} for a zero-thickness domain"
                )
            scales.append(1.0)
            new_lengths.append(length)
            continue

        new_length = length + extension
        if new_length <= 0.0:
            raise InpParseError(
                f"Requested extension along {axis} results in a non-positive length"
            )

        scales.append(new_length / length)
        new_lengths.append(new_length)

    new_lines = list(lines)

    for node in nodes:
        new_x = min_x + (node.x - min_x) * scales[0]
        new_y = min_y + (node.y - min_y) * scales[1]
        new_z = min_z + (node.z - min_z) * scales[2]

        new_lines[node.line_index] = (
            f"{node.node_id}, {new_x:.6f}, {new_y:.6f}, {new_z:.6f}{node.suffix}"
        )

    new_text = "\n".join(new_lines)
    if trailing_newline:
        new_text += "\n"

    output_path.write_text(new_text, encoding="utf-8")

    return StretchSummary(
        node_count=len(nodes),
        original_lengths=original_lengths,
        new_lengths=tuple(new_lengths),
    )

"""STEP to INP conversion helpers.

This module implements a lightweight, dependency free conversion routine that
extracts vertices from a STEP file and emits a toy finite element mesh in the
ABAQUS ``.inp`` format.  The implementation is intentionally conservative so it
can operate without the full OpenFOAM or pythonocc toolchain being available in
this execution environment.  The generated mesh is sufficient for
proof-of-concept experiments and documents how a real converter could integrate
with OpenFOAM.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
import re
from typing import Iterable, List, Sequence, Tuple

Coordinate = Tuple[float, float, float]


@dataclass
class ConversionSummary:
    """Summary of the conversion result."""

    node_count: int
    element_count: int
    ignored_points: int = 0


_COORDINATE_PATTERN = re.compile(
    r"\(\s*(?P<x>[-+]?[0-9]*\.?[0-9]+(?:[Ee][-+]?[0-9]+)?)"
    r"\s*,\s*(?P<y>[-+]?[0-9]*\.?[0-9]+(?:[Ee][-+]?[0-9]+)?)"
    r"\s*,\s*(?P<z>[-+]?[0-9]*\.?[0-9]+(?:[Ee][-+]?[0-9]+)?)\s*\)"
)


class StepParseError(RuntimeError):
    """Raised when the STEP file cannot be parsed."""


class InputFileError(RuntimeError):
    """Raised when input validation fails."""


def _normalise_coordinates(coordinates: Iterable[Coordinate]) -> List[Coordinate]:
    """Remove duplicate coordinates while preserving order."""

    seen = set()
    unique: List[Coordinate] = []
    for coord in coordinates:
        if coord not in seen:
            seen.add(coord)
            unique.append(coord)
    return unique


def _chunked(sequence: Sequence[Coordinate], chunk_size: int) -> Iterable[Sequence[Coordinate]]:
    """Yield *chunk_size* sized slices from *sequence*."""

    for start in range(0, len(sequence), chunk_size):
        yield sequence[start : start + chunk_size]


def _extract_coordinates(step_text: str) -> List[Coordinate]:
    """Extract XYZ coordinates from the STEP document.

    The parser is intentionally simple but performs well enough for STEP files
    that contain explicit coordinate triples in standard formats.  The
    conversion uses a forgiving regular expression that can match both comma and
    semicolon separated triples, which covers STEP files exported by popular CAD
    tools.
    """

    coordinates: List[Coordinate] = []
    for match in _COORDINATE_PATTERN.finditer(step_text):
        try:
            x = float(match.group("x"))
            y = float(match.group("y"))
            z = float(match.group("z"))
        except ValueError as exc:  # pragma: no cover - defensive guard
            raise StepParseError("Failed to parse coordinate triple") from exc
        coordinates.append((x, y, z))

    return coordinates


def _format_inp(nodes: Sequence[Coordinate], elements: Sequence[Sequence[int]], source: Path) -> str:
    """Build the textual contents of the ABAQUS ``.inp`` mesh file."""

    lines = [
        "*Heading",
        f"** Converted from STEP: {source.name}",
        "** This file was generated by the lightweight mesh_converter tool.",
        "*Node",
    ]

    for index, (x, y, z) in enumerate(nodes, start=1):
        lines.append(f"{index}, {x:.6f}, {y:.6f}, {z:.6f}")

    if elements:
        lines.append("*Element, type=T3D2")
        for index, element in enumerate(elements, start=1):
            node_indices = ", ".join(str(node_index) for node_index in element)
            lines.append(f"{index}, {node_indices}")

    return "\n".join(lines) + "\n"


def convert_step_to_inp(input_path: Path | str, output_path: Path | str) -> ConversionSummary:
    """Convert *input_path* STEP file into an ABAQUS ``.inp`` mesh file.

    The converter extracts all coordinate triples present in the STEP document
    and constructs a simple element connectivity table by grouping the
    coordinates into triples.  Real-world pipelines would typically perform a
    more sophisticated meshing step (e.g. via ``gmsh`` or OpenFOAM utilities).

    Parameters
    ----------
    input_path:
        The STEP file to read.  Files must use either the ``.stp`` or
        ``.step`` extensions.
    output_path:
        Destination path for the generated ``.inp`` file.
    """

    input_path = Path(input_path)
    output_path = Path(output_path)

    if not input_path.exists():
        raise InputFileError(f"Input STEP file does not exist: {input_path}")

    if input_path.suffix.lower() not in {".stp", ".step"}:
        raise InputFileError("Input file must have a .stp or .step extension")

    step_text = input_path.read_text(encoding="utf-8", errors="ignore")
    raw_coordinates = _extract_coordinates(step_text)

    if not raw_coordinates:
        raise StepParseError("No coordinate triples found in STEP file")

    nodes = _normalise_coordinates(raw_coordinates)
    ignored_points = len(raw_coordinates) - len(nodes)

    elements: List[List[int]] = []
    for chunk in _chunked(nodes, 3):
        if len(chunk) == 3:
            # Nodes are 1-indexed in the .inp format
            indices = [nodes.index(node) + 1 for node in chunk]
            elements.append(indices)

    inp_text = _format_inp(nodes, elements, input_path)
    output_path.write_text(inp_text, encoding="utf-8")

    return ConversionSummary(
        node_count=len(nodes),
        element_count=len(elements),
        ignored_points=ignored_points,
    )
